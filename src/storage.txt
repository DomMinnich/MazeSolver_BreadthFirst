
///////////// Not working multi maze reader printer 
   
    
public class Maze {
    private Cell[][] maze;
    private SetArr<Cell> visited;
    private QueueArr<Cell> toVisit;
    private int rows;
    private int cols;
    private Cell start;
    private Cell finish;
    SetArr<Cell> visitedMazes;
    int numOfMazes = 2;

    public Maze(Scanner input) {
        int mazeNum = getNumMazes();
        for (int k = 0; k < mazeNum; k++) {
            rows = Integer.parseInt(input.nextLine());
            cols = Integer.parseInt(input.nextLine());
            input.nextLine();
            maze = new Cell[rows][cols];
            visited = new SetArr<Cell>();
            toVisit = new QueueArr<Cell>();
            for (int i = 0; i < rows; i++) {
                String line = input.nextLine();
                for (int j = 0; j < cols; j++) {
                    maze[i][j] = new Cell();
                    if (i == 0 && j == 1) {
                        start = maze[i][j];
                        start.setCellChar('S');
                    } else if (i == rows - 1 && j == cols - 2) {
                        finish = maze[i][j];
                        finish.setCellChar('F');
                    }
                    //set CellChar value and set neighbors
                    else if (line.charAt(j) == '|') {
                        maze[i][j].setCellChar('|');
                    } else if (line.charAt(j) == '_') {
                        maze[i][j].setCellChar('_');
                        if (j == 0) {
                            maze[i][j].setNeighbor(Cell.EAST);
                        } else if (j == cols - 1) {
                            maze[i][j].setNeighbor(Cell.WEST);
                        } else {
                            maze[i][j].setNeighbor(Cell.EAST);
                            maze[i][j].setNeighbor(Cell.WEST);
                        }
                    } else if (line.charAt(j) == ' ') {
                        maze[i][j].setCellChar(' ');
                        if (i == 0) {
                            maze[i][j].setNeighbor(Cell.SOUTH);
                        } else if (i == rows - 1) {
                            maze[i][j].setNeighbor(Cell.NORTH);
                        } else {
                            maze[i][j].setNeighbor(Cell.NORTH);
                            maze[i][j].setNeighbor(Cell.SOUTH);
                        }
                        if (j == 0) {
                            maze[i][j].setNeighbor(Cell.EAST);
                        } else if (j == cols - 1) {
                            maze[i][j].setNeighbor(Cell.WEST);
                        } else {
                            maze[i][j].setNeighbor(Cell.EAST);
                            maze[i][j].setNeighbor(Cell.WEST);
                        }
                    }
                }
            }
           // add maze to visitedMazes
        Maze m = new Maze(input);
       visitedMazes.addMaze(m);
        }
    }






        //             else if (line.charAt(j) == '|') {
        //                 if (j > 0) {
        //                     maze[i][j].setNeighbor(Cell.WEST);
        //                     maze[i][j - 1].setNeighbor(Cell.EAST);
        //                     // set the cell char
        //                     maze[i][j].setCellChar(line.charAt(j));
        //                 }
        //                 if (i > 0) {
        //                     maze[i][j].setNeighbor(Cell.NORTH);
        //                     // set the cell char
        //                     maze[i][j].setCellChar(line.charAt(j));
        //                 }
        //             } else if (line.charAt(j) == '_') {
        //                 if (j > 0) {
        //                     maze[i][j].setNeighbor(Cell.WEST);
        //                     maze[i][j - 1].setNeighbor(Cell.EAST);
        //                     // set the cell char
        //                     maze[i][j].setCellChar(line.charAt(j));
        //                 }
        //             } else if (line.charAt(j) == ' ') {
        //                 if (j > 0) {
        //                     maze[i][j].setNeighbor(Cell.WEST);
        //                     maze[i][j - 1].setNeighbor(Cell.EAST);
        //                     // set the cell char
        //                     maze[i][j].setCellChar(line.charAt(j));
        //                 }
        //                 if (i > 0) {
        //                     maze[i][j].setNeighbor(Cell.NORTH);
        //                     maze[i - 1][j].setNeighbor(Cell.SOUTH);
        //                     // set the cell char
        //                     maze[i][j].setCellChar(line.charAt(j));
        //                 }
        //             }
        //         }
        //     }
        // }
        //add maze to visitedMazes
    //     Maze m = new Maze(input);
    //     visitedMazes.addMaze(m);
    // }


    // public solveMaze()
    // This method should solve the maze by finding a path from the start to the
    // finish.
    // When the path from start to finish is found, the method should set the
    // cellChar of each cell in the path to 'X'
    // The method should return true if a path is found and false if no path is
    // found.
    // The cells that have been visited should be stored in the Set<Cell> visited
    // The cells that have not yet been visited should be stored in the Queue<Cell>
    // toVisit
    // Use Location class to store the row and column of the cell
    // The maze has '|' as walls and are not passable
    // The maze has '_' which can be passed through going west or east
    // The maze has ' ' which can be passed through going north or south or east or
    // west

    public boolean solveMaze2() {
        System.out.println("add the start cell to the queue");
        toVisit.enqueue(start);
        // while the queue is not empty
        System.out.println("while the queue is not empty");
        while (!toVisit.isEmpty()) {
            // dequeue the cell
            System.out.println("dequeue the cell");
            Cell current = toVisit.dequeue();
            // if the cell is the finish
            System.out.println("if the cell is the finish");
            if (current == finish) {
                // return true
                System.out.println("return true");
                return true;

            }
            // if the cell is not in the visited set
            System.out.println("if the cell is not in the visited set");
            if (!visited.contains(current)) {
                // add the cell to the visited set
                System.out.println("add the cell to the visited set");
                visited.enter(current);
                // for each neighbor of the cell
                System.out.println("for each neighbor of the cell");
                for (int i = 0; i < 4; i++) {
                    // if the neighbor is not null
                    System.out.println("if the neighbor is not null");
                    if (current.getNeighbor(i) != null) {
                        // if the neighbor is not in the visited set
                        System.out.println("if the neighbor is not in the visited set");
                        if (!visited.contains(current.getNeighbor(i))) {
                            // add the neighbor to the queue
                            System.out.println("add the neighbor to the queue");
                            toVisit.enqueue(current.getNeighbor(i));
                        }
                    }
                }
            }
        }
        // replace visited cells with 'X'
        System.out.println("replace visited cells with 'X'");
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (visited.contains(maze[i][j])) {
                    maze[i][j].setCellChar('X');
                }
            }
        }

        // return false
        return false;
    }

    public boolean solveMaze() {
        toVisit.enqueue(start);
        System.out.println("Step 1: Add the start cell to the queue");
        while (!toVisit.isEmpty()) {
            System.out.println("Step 2: Dequeue the cell");
            Cell current = toVisit.dequeue();
            if (current.equals(finish)) {
                return true;
            }
            visited.enter(current);
            if (current.hasNeighbor(Cell.NORTH) && !visited.contains(current.getNeighbor(Cell.NORTH))) {
                toVisit.enqueue(current.getNeighbor(Cell.NORTH));
            }
            if (current.hasNeighbor(Cell.SOUTH) && !visited.contains(current.getNeighbor(Cell.SOUTH))) {
                toVisit.enqueue(current.getNeighbor(Cell.SOUTH));
            }
            if (current.hasNeighbor(Cell.EAST) && !visited.contains(current.getNeighbor(Cell.EAST))) {
                toVisit.enqueue(current.getNeighbor(Cell.EAST));
            }
            if (current.hasNeighbor(Cell.WEST) && !visited.contains(current.getNeighbor(Cell.WEST))) {
                toVisit.enqueue(current.getNeighbor(Cell.WEST));
            }
        }
        return false;
    }

    public boolean hasPath() {
        return solveMaze();
    }

    public String toStringA() {
        int t = 0;
        while (!(t == visitedMazes.size())) { 

            String result = "";
            for (int i = 0; i < rows; i++) {
                result += "\n";
                for (int j = 0; j < cols; j++) {
                    result += maze[i][j].getCellChar();
                }
                result += "";
            }
            return result;
        }
        return "";
    }


    //     String result = "";
    //     for (int i = 0; i < rows; i++) {
    //         result += "\n";
    //         for (int j = 0; j < cols; j++) {
    //             result += maze[i][j].getCellChar();
    //         }
    //         result += "";
    //     }
    //     return result;
    // }

    // how an int value of how many mazes are in the file
    public int getNumMazes() {
        return numOfMazes;
    }

    // set the number of mazes in the file
    public void setNumMazes(int numMazes) {
        this.numOfMazes = numMazes;
    }

    public static void main(String[] args) throws FileNotFoundException {
        // get file from user
        Scanner input = new Scanner(System.in);
        System.out.println("Enter the name of the file containing the maze: ");
        String fileName = input.nextLine();
        File file = new File(fileName);
        Scanner fileInput = new Scanner(file);
        Maze maze = new Maze(fileInput);
        System.out.println(maze.toStringA());
    }
}

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public static void main(String[] args) throws FileNotFoundException {
        //get fiel name from user
        Scanner input = new Scanner(System.in);
        System.out.println("Enter the file name: ");
        String fileName = input.nextLine();
        //create a scanner object
        Scanner file = new Scanner(new File(fileName));
        //create a maze object
        Maze maze = new Maze(file);
        //print the maze
        System.out.println(maze.toStringB());
        //solve the maze
        maze.solveMaze();
        //print the maze
        System.out.println(maze.toString());
    }
}




















    public String toString() {
        String result = "";
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (maze[i][j].equals(start)) {
                    result += "S";
                } else if (maze[i][j].equals(finish)) {
                    result += "F";
                } else if (visited.contains(maze[i][j])) {
                    result += "X";
                } else {
                    result += maze[i][j].getSymbol();
                }
            }
            result += " ";
        }
        return result;
    }


    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Enter the name of the file containing the maze: ");
        String fileName = input.nextLine();
        try {
            Scanner file = new Scanner(new File(fileName));
            Maze maze = new Maze(file);
            System.out.println(maze);
            if (maze.hasPath()) {
                System.out.println("There is a path from the start to the finish.");
            } else {
                System.out.println("There is no path from the start to the finish.");
            }
            System.out.println(maze);
        } catch (FileNotFoundException e) {
            System.out.println("File not found.");
        }
    }
}














public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        Maze maze = new Maze(input);
        maze.solve();
        maze.printMaze();

    }

    public Maze(Scanner input) {
        try {
            System.out.print("Enter the file name with extension : ");
            input = new Scanner(System.in);
            File file = new File(input.nextLine());
            input = new Scanner(file);
        } catch (Exception e) {
            System.out.println("File not found");
            System.exit(0);
        }




/*
 * 1
 * public class Maze (Scanner input)
 * The maze has '|' as walls and are not passable
 * The maze has '_' which can be passed through going west or east
 * The maze has ' ' which can be passed through going north or south or east or west
 * The starting position is assumed to be in the upper left corner, while the finishing position is assumed to be in the lower right corner.
 * Internally the maze should be represented as a two-dimensional array of Cells
 */

/*
 * 2
 * Method public findPath()
 * This method will find the path from the start to the end.
 * If path exists the method records the path and marks the path with 'X'
 * The algorithm operates according to the following pseudo-code: Visit the starting Location. Add this Location to the Set. Enqueue the Location in the Queue.
 */

/*
 * 3
 * Method public hasPath()
 * This method returns true if a path exists, false otherwise based on the solve() method
 */

/*
 * 4 
 * public printMaze()
 * This method prints the maze to the console
 * 
 */








/*

//Updated to new 10/27/ 4:41pm
import java.util.Scanner;

public class Maze {
    private Cell[][] maze;
    private int rows;
    private int cols;
    private SetArr<Cell> visited;
    private QueueArr<Cell> toVisit;
    private Cell start;
    private Cell finish;

    public Maze(Scanner input) {
        rows = input.nextInt();
        cols = input.nextInt();
        input.nextLine();
        maze = new Cell[rows][cols];
        // Start is the very first cell in the maze
        // Finish is the very last cell in the maze
        start = maze[0][0];
        finish = maze[rows - 1][cols - 1];
        visited = new SetArr<Cell>();
        toVisit = new QueueArr<Cell>();
        for (int i = 0; i < rows; i++) {
            String line = input.nextLine();
            for (int j = 0; j < cols; j++) {
                maze[i][j] = new Cell();
                maze[i][j].setRow(i);
                maze[i][j].setCol(j);
                if (line.charAt(j) == '1') {
                    if (i > 0) {
                        maze[i][j].setNeighbor(Cell.NORTH);
                        maze[i - 1][j].setNeighbor(Cell.SOUTH);
                    }
                    if (j > 0) {
                        maze[i][j].setNeighbor(Cell.WEST);
                        maze[i][j - 1].setNeighbor(Cell.EAST);
                    }
                }
            }
        }
    }

    public String asText() {
        String result = "";
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (maze[i][j].isOnPath()) {
                    result += "@";
                } else if (maze[i][j].hasNeighbor(Cell.NORTH) && maze[i][j].hasNeighbor(Cell.SOUTH)
                        && maze[i][j].hasNeighbor(Cell.EAST) && maze[i][j].hasNeighbor(Cell.WEST)) {
                    result += "1";
                } else {
                    result += "0";
                }
            }
            result += " ";
        }
        return result;
    }

    public boolean findPath() {
        toVisit.enqueue(start);
        while (!toVisit.isEmpty()) {
            Cell current = toVisit.dequeue();
            if (current == finish) {
                return true;
            }
            visited.enter(current);
            if (current.hasNeighbor(Cell.NORTH) && !visited.contains(maze[current.getRow() - 1][current.getCol()])) {
                toVisit.enqueue(maze[current.getRow() - 1][current.getCol()]);
            }
            if (current.hasNeighbor(Cell.SOUTH) && !visited.contains(maze[current.getRow() + 1][current.getCol()])) {
                toVisit.enqueue(maze[current.getRow() + 1][current.getCol()]);
            }
            if (current.hasNeighbor(Cell.EAST) && !visited.contains(maze[current.getRow()][current.getCol() + 1])) {
                toVisit.enqueue(maze[current.getRow()][current.getCol() + 1]);
            }
            if (current.hasNeighbor(Cell.WEST) && !visited.contains(maze[current.getRow()][current.getCol() - 1])) {
                toVisit.enqueue(maze[current.getRow()][current.getCol() - 1]);
            }
        }
        return false;
    }

    public boolean pathFound() {
        return findPath();
    }

}


 */
