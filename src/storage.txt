

   
    public static void main(String[] args) throws FileNotFoundException {
        //get fiel name from user
        Scanner input = new Scanner(System.in);
        System.out.println("Enter the file name: ");
        String fileName = input.nextLine();
        //create a scanner object
        Scanner file = new Scanner(new File(fileName));
        //create a maze object
        Maze maze = new Maze(file);
        //print the maze
        System.out.println(maze.toStringB());
        //solve the maze
        maze.solveMaze();
        //print the maze
        System.out.println(maze.toString());
    }
}




















    public String toString() {
        String result = "";
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (maze[i][j].equals(start)) {
                    result += "S";
                } else if (maze[i][j].equals(finish)) {
                    result += "F";
                } else if (visited.contains(maze[i][j])) {
                    result += "X";
                } else {
                    result += maze[i][j].getSymbol();
                }
            }
            result += " ";
        }
        return result;
    }


    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Enter the name of the file containing the maze: ");
        String fileName = input.nextLine();
        try {
            Scanner file = new Scanner(new File(fileName));
            Maze maze = new Maze(file);
            System.out.println(maze);
            if (maze.hasPath()) {
                System.out.println("There is a path from the start to the finish.");
            } else {
                System.out.println("There is no path from the start to the finish.");
            }
            System.out.println(maze);
        } catch (FileNotFoundException e) {
            System.out.println("File not found.");
        }
    }
}














public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        Maze maze = new Maze(input);
        maze.solve();
        maze.printMaze();

    }

    public Maze(Scanner input) {
        try {
            System.out.print("Enter the file name with extension : ");
            input = new Scanner(System.in);
            File file = new File(input.nextLine());
            input = new Scanner(file);
        } catch (Exception e) {
            System.out.println("File not found");
            System.exit(0);
        }




/*
 * 1
 * public class Maze (Scanner input)
 * The maze has '|' as walls and are not passable
 * The maze has '_' which can be passed through going west or east
 * The maze has ' ' which can be passed through going north or south or east or west
 * The starting position is assumed to be in the upper left corner, while the finishing position is assumed to be in the lower right corner.
 * Internally the maze should be represented as a two-dimensional array of Cells
 */

/*
 * 2
 * Method public findPath()
 * This method will find the path from the start to the end.
 * If path exists the method records the path and marks the path with 'X'
 * The algorithm operates according to the following pseudo-code: Visit the starting Location. Add this Location to the Set. Enqueue the Location in the Queue.
 */

/*
 * 3
 * Method public hasPath()
 * This method returns true if a path exists, false otherwise based on the solve() method
 */

/*
 * 4 
 * public printMaze()
 * This method prints the maze to the console
 * 
 */








/*

//Updated to new 10/27/ 4:41pm
import java.util.Scanner;

public class Maze {
    private Cell[][] maze;
    private int rows;
    private int cols;
    private SetArr<Cell> visited;
    private QueueArr<Cell> toVisit;
    private Cell start;
    private Cell finish;

    public Maze(Scanner input) {
        rows = input.nextInt();
        cols = input.nextInt();
        input.nextLine();
        maze = new Cell[rows][cols];
        // Start is the very first cell in the maze
        // Finish is the very last cell in the maze
        start = maze[0][0];
        finish = maze[rows - 1][cols - 1];
        visited = new SetArr<Cell>();
        toVisit = new QueueArr<Cell>();
        for (int i = 0; i < rows; i++) {
            String line = input.nextLine();
            for (int j = 0; j < cols; j++) {
                maze[i][j] = new Cell();
                maze[i][j].setRow(i);
                maze[i][j].setCol(j);
                if (line.charAt(j) == '1') {
                    if (i > 0) {
                        maze[i][j].setNeighbor(Cell.NORTH);
                        maze[i - 1][j].setNeighbor(Cell.SOUTH);
                    }
                    if (j > 0) {
                        maze[i][j].setNeighbor(Cell.WEST);
                        maze[i][j - 1].setNeighbor(Cell.EAST);
                    }
                }
            }
        }
    }

    public String asText() {
        String result = "";
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (maze[i][j].isOnPath()) {
                    result += "@";
                } else if (maze[i][j].hasNeighbor(Cell.NORTH) && maze[i][j].hasNeighbor(Cell.SOUTH)
                        && maze[i][j].hasNeighbor(Cell.EAST) && maze[i][j].hasNeighbor(Cell.WEST)) {
                    result += "1";
                } else {
                    result += "0";
                }
            }
            result += " ";
        }
        return result;
    }

    public boolean findPath() {
        toVisit.enqueue(start);
        while (!toVisit.isEmpty()) {
            Cell current = toVisit.dequeue();
            if (current == finish) {
                return true;
            }
            visited.enter(current);
            if (current.hasNeighbor(Cell.NORTH) && !visited.contains(maze[current.getRow() - 1][current.getCol()])) {
                toVisit.enqueue(maze[current.getRow() - 1][current.getCol()]);
            }
            if (current.hasNeighbor(Cell.SOUTH) && !visited.contains(maze[current.getRow() + 1][current.getCol()])) {
                toVisit.enqueue(maze[current.getRow() + 1][current.getCol()]);
            }
            if (current.hasNeighbor(Cell.EAST) && !visited.contains(maze[current.getRow()][current.getCol() + 1])) {
                toVisit.enqueue(maze[current.getRow()][current.getCol() + 1]);
            }
            if (current.hasNeighbor(Cell.WEST) && !visited.contains(maze[current.getRow()][current.getCol() - 1])) {
                toVisit.enqueue(maze[current.getRow()][current.getCol() - 1]);
            }
        }
        return false;
    }

    public boolean pathFound() {
        return findPath();
    }

}


 */
